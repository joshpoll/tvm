/*!
 * Copyright (c) 2018 by Josh Pollock
 * \file partial_eval.cc
 *
 * An online partial evaluator based on "A Type-directed, On-line, Partial
 * Evaluator for a Polymorphic Language" by Tim Sheard. We will eventually
 * revisit this choice. Currently handles only a limited subset of the language
 * features described in the paper.
 *
 * Programs consist of static (available at compile-time) and dynamic (available
 * at run-time) data. The goal of a partial evaluator is to use static data to
 * precompute as much of the program as possible, improving runtime performance.
 * The partial evaluator thus subsumes constant folding and dead-code
 * elimination. It also simplifies complicated function applications.
 *
 * This evaluator is not perfect. In some cases it may duplicate computation,
 * resulting in suboptimal performance. In the presence of complicated
 * recursion, the pass may not terminate.
 *
 * For an introduction to partial evaluation see
 * - http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.37.9354&rep=rep1&
 *   * type=pdf
 * - http://phoenix.inria.fr/publications/talks/introduction.pdf
 * - https://dl.acm.org/citation.cfm?id=243447
 * - https://softwarefoundations.cis.upenn.edu/plf-current/PE.html
 *
 * The classic text on partial evaluation is
 * - https://www.itu.dk/~sestoft/pebook/jonesgomardsestoft.ps
 *
 * For a description of this flavor of partial evaluation (type-directed partial
 * evaluation or normalization by evaluation) see
 * - https://pdfs.semanticscholar.org/1ef8/743d6f444f1fbad085a86ec93a5921813f2a.pdf
 * - Type-Directed Partial Evaluation by Danvy
 * - Sections 2.4, 2.5 of Normalisation by Evaluation in the Compilation of
 *   Typed Functional Programming Languages by Lindley
 *
 * For sophisticated implementation details see
 * - Sections 4 and 5 of Normalisation by Evaluation in the Compilation of Typed
 *   Functional Programming Languages by Lindley
 */
#include <tvm/relay/expr_functor.h>
#include <tvm/relay/interpreter2.h>

namespace tvm {
namespace relay {
namespace jmp {

using FInterpreter = runtime::TypedPackedFunc<Value(Expr)>;
using FClosureInvoker = runtime::TypedPackedFunc<Value(Closure, tvm::Array<Value>)>;

/*! \brief A dynamic value. */
class Dynamic;

/*! \brief The container type of Dynamics. */
class DynamicNode : public ValueNode {
 public:
  /*! \brief An arbitrary Relay expr.
   */
  Expr expr;

  DynamicNode() {}

  void VisitAttrs(tvm::AttrVisitor* v) final {
    v->Visit("expr", &expr);
  }

  TVM_DLL static Dynamic make(Expr expr);

  static constexpr const char* _type_key = "relay.Dynamic";
  TVM_DECLARE_NODE_TYPE_INFO(DynamicNode, ValueNode);
};

RELAY_DEFINE_NODE_REF(Dynamic, DynamicNode, Value);

class PartialEvaluator {
  public:
    explicit PartialEvaluator(FInterpreter interp, FClosureInvoker closure_invoker)
        : interp_(interp), closure_invoker_(closure_invoker) { }

    // Reify (with the help of Reflect) turns a Value back into an Expr
    Expr Reify(const Value& value) {
      if (const TensorValueNode *tensor = value.as<TensorValueNode>()) {
        return ConstantNode::make(tensor->data);
      } else if (const ClosureNode *closure_node = value.as<ClosureNode>()) {
        // eta expand (f -> (x) => f(x)) and invoke the closure?

        // 1. make an array of fresh vars, give them the same type as the function
        //    params in the closure (since we are eta-expanding the function node)

        // clone params
        tvm::Array<Var> eta_vars;
        for (auto param : closure_node->func->params) {
          eta_vars.push_back(VarNode::make(param->name_hint(), param->type_annotation));
        }

        // reflect vars
        tvm::Array<Value> reflected_vars;
        for (auto var : eta_vars) {
          reflected_vars.push_back(Reflect(var->type_annotation, var));
        }

        // return FunctionNode::make(eta_vars, Reify(closure_invoker_(closure,
        // reflected_vars)));
        auto closure = GetRef<Closure>(closure_node);
        return FunctionNode::make(eta_vars, Reify(closure_invoker_(closure, reflected_vars)), closure_node->func->ret_type, tvm::Array<TypeVar>());
      } else if (const TupleValueNode *tuple = value.as<TupleValueNode>()) {
        assert(false);
      } else if (const DynamicNode *dynamic = value.as<DynamicNode>()) {
        return dynamic->expr;
      } else { assert(false); }
    };

  private:
    // Internal interpreter.
    FInterpreter interp_;
    // Internal closure invoker.
    FClosureInvoker closure_invoker_;

    Value Reflect(const Type& type, const Expr& expr) {
      if (const TensorTypeNode *tensor_type = type.as<TensorTypeNode>()) {
        const ConstantNode *tensor = expr.as<ConstantNode>();
        return TensorValueNode::make(tensor->data);
      } else if (const FuncTypeNode *func_type = type.as<FuncTypeNode>()) {
        assert(false);
      } else { assert(false); }
    };
};

Expr PartialEval(const Expr& expr) {
      DLContext ctx;
      ctx.device_type = kDLCPU;
      ctx.device_id = 0;
      Target target = Target::create("llvm");
      // use a fresh build context
      // in case we are already in a build context.
      BuildConfigContext fresh_build_ctx(build_config());

      auto intrp = CreateInterpreter(Module(nullptr), ctx, target);
      auto pe = PartialEvaluator(intrp, CreateClosureInvoker(Module(nullptr), ctx, target));

      // Interpret the expr to a value then reify it.
      return pe.Reify(intrp(expr));
};

}  // namespace jmp
}  // namespace relay
}  // namespace tvm
